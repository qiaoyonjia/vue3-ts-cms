**1.如何实现父组件调用子组件函数？**
在子组件中定义函数，并通过 defineExpose({})暴露出去
父组件在使用子组件的时候绑定 ref <PanelAccount ref="accountRef" />
通过 ref.value.函数名 来执行子组件的函数

**权限控制**
RBAC 基于角色的访问控制
权限管理:根据登录用户的不同,呈现不同的后台管理系统内容(具备不同的操作权限)

根据角色分配权限
超管 管理员

**动态路由**
根据用户的权限信息，动态的添加路由，而不是一次性注册所有的路由

```
1.基于角色的动态路由管理
const roles = {
  "superadmin":[所有的路由] => router.main.children
  "admin":[部分路由] => router.main.children
  "service":[少部分路由] => router.main.children
}
使用较多
弊端：每增加一个角色，都要增加key/value，如果项目上线了，前端新加代码很麻烦，而且每增加一个角色，就需要重新发布一次

2.基于菜单的动态路由管理
userMenus => 动态展示菜单
系统总览/核心技术/用户管理/角色管理
映射成路由对象
此方案最合理

根据菜单动态的添加路由对象
· 获取菜单  代码书写位置
· 动态获取所有的路由对象  路由对象都在独立的文件中，从文件中将所有路由对象先读取数组中
· 根据菜单去匹配正确的路由  router.addRoute

问题：刷新之后所有动态添加的路由都会丢失，因为刷新之后，代码重新执行，不会再走login的接口，所以注册的只是
router的index.js中注册的路由
解决：刷新的时候再次映射一次路由,在 store 的 login.ts中增加一个action，为了刷新时重新加载所有路由，在state中不给token，menus等赋值，在这个方法中先从缓存中拿到token、userInfo、userMenus，
然后判断，如果三者都存在，说明现在是已登录状态，此时给state中的状态赋值，然后调用动态添加路由的方法
什么时候调用这个方法？
在用户强制刷新后，代码会重新执行，所以可以在main.ts中，use pinia之后，use route之前调用这个action，去动态添加路由
```

**两个子组件如何通信，比如查询和列表展示属于一个父组件**
全局事件总线
子组件 A 将自定义事件暴露给父组件
子组件 B 将需要执行的函数暴露出去
父组件通过 ref 拿到子组件 B 暴露的方法

**nextTick**
在 vue 中更改响应式状态时，最终的 DOM 更新并不是同步生效的，而是由 vue 将它们缓存在一个队列汇总，直到下一个 tick 才一起执行，这样是为了
确保每个组件无论发生多少状态改变，都只执行一次更新

nextTick 可以在状态改变之后立即使用，以等待 DOM 更新完成
nextTick 是宏任务还是微任务？
在 vue3 中是微任务

**按钮权限控制**
